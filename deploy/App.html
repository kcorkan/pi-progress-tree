<!DOCTYPE html>
<html>
<head>
    <title>pi-progress-tree</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Fri May 30 2014 22:46:09 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Fri May 30 2014 22:46:09 GMT-0600 (MDT)";
        var CHECKSUM = 43572876578;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc2/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>--</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.ProgressBarTemplate', {
    requires: [],
    extend: 'Ext.XTemplate',

    config: {
        /**
         * @cfg {String} width define a width if necessary to fit where it's being used
         */
        width: '100%',
        /**
         * @cfg {String} height define a height if necessary to fit where it's being used
         */
        height: '20px',
        /**
         * @cfg {String} numeratorField will divide numeratorField value / denominatorField value to 
         * get percent done
         */
        numeratorField: 'percentDone',
        /**
         * @cfg {String} denominatorField will divide numeratorField value / denominatorField value to 
         * get percent done
         */
        denominatorField: 'percentDone',
        /**
         * @cfg {Function} showDangerNotificationFn A function that should return true to show a triangle in the top right to denote something is missing.
         * Defaults to:
         *      function(){ return false; }
         */
        showDangerNotificationFn: function() {
            return false;
        },

        /**
         * @cfg {Function} (required)
         * A function that returns the color for the percent done bar in hex
         */
        calculateColorFn: function(recordData) {            
            var numerator = recordData[this.config.numeratorField] || 0;
            var denominator = recordData[this.config.denominatorField] || 0;
            
            var percentDone = 0;
            
            if ( denominator > 0 ) {
                percentDone = numerator / denominator;
            }
                
            var color = '#cff';
            return color;
//            var start_date = recordData['PlannedStartDate'] ;
//            if ( start_date === null ) { 
//                start_date = new Date();
//            }
//            var end_date = recordData['PlannedEndDate'];
//            
//            if ( end_date !== null ) {
//                var color = Rally.util.HealthColorCalculator.calculateHealthColor({
//                    startDate: start_date,
//                    endDate: end_date,
//                    asOfDate: new Date(),
//                    percentComplete: percentDone
//                }).hex;
//            }
            

        },

        /**
         * @cfg {Boolean} (optional)
         * A boolean that indicates whether the progress bar is clickable
         */
        isClickable: false,

        /**
         * @cfg {Boolean} If the percent done is 0%, do not show the bar at all
         */
        showOnlyIfInProgress: false,

        /**
         * @cfg {Function}
         * A function that returns the text to show in the progress bar.
         * Defaults to a function that returns the percentage complete.
         */
        generateLabelTextFn: function (recordData) {
            return this.calculatePercent(recordData) + '%';
        }
    },

    constructor: function(config) {
        this.initConfig(config);
        config = this.config;
        var templateConfig = [
            '<tpl if="this.shouldShowPercentDone(values)">',
                '<div class="progress-bar-container field-{[this.getDenominatorField()]} {[this.getClickableClass()]} {[this.getContainerClass(values)]}" style="{[this.getDimensionStyle()]}">',
                    '<div class="progress-bar" style="background-color: {[this.calculateColor(values)]}; width: {[this.calculateWidth(values)]}; "></div>',
                    '<tpl if="this.showDangerNotification(values)">',
                        '<div class="progress-bar-danger-notification"></div>',
                    '</tpl>',
                    '<div class="progress-bar-label">',
                        '{[this.generateLabelText(values)]}',
                    '</div>',
                '</div>',
            '</tpl>',
            {
                shouldShowPercentDone: function(recordData) {
                    return true;
                },
                getContainerClass: function(recordData) {
                    if (recordData && recordData.FormattedID) {
                        return recordData.FormattedID + '-' + config.denominatorField;
                    }
                    return '';
                },
                getClickableClass: function(){
                    return config.isClickable ? 'clickable' : '';
                },
                getDimensionStyle: function(){
                    return 'width: ' + config.width + '; height: ' + config.height + '; line-height: ' + config.height;
                },
                calculateWidth: function (recordData) {
                    var percentDone = this.calculatePercent(recordData);
                    return percentDone > 100 ? '100%' : percentDone + '%';
                },
                calculatePercent: function (recordData) {
                    var numerator = recordData[this.config.numeratorField] || 0;
                    var denominator = recordData[this.config.denominatorField] || 0;
                    
                    var percentDone = 0;
                    if ( denominator > 0 ) {
                        percentDone = numerator / denominator;
                    }
                    return Math.round(percentDone * 100);
                },
                generateLabelText: config.generateLabelTextFn,
                calculateColor: config.calculateColorFn,
                showDangerNotification: config.showDangerNotificationFn
            }];

        return this.callParent(templateConfig);

    }
});

var convertDelta = function(value,record) {
    var done = record.get('__accepted_rollup') || 0;
    var original = record.get('__original_value');
    if ( original || original === 0 ) {
        return done - original;
    }
    return "";
};
var convertRemaining = function(value,record) {
    var done = record.get('__accepted_rollup') || 0;
    var total = record.get('__rollup') || 0;
    var delta = total-done;
    return delta;
};

var convertProgressByOriginal = function(value,record) {
    var numerator = record.get('__accepted_rollup') || 0;
    var denominator = record.get('__original_value') || 0;
    var percentDone = 0;
    if ( denominator > 0 ) {
        percentDone = numerator / denominator;
    }
    return percentDone;
};

var convertProgressByRollup = function(value,record) {
    var numerator = record.get('__accepted_rollup') || 0;
    var denominator = record.get('__rollup') || 0;
    var percentDone = 0;
    if ( denominator > 0 ) {
        percentDone = numerator / denominator;
    }
    return percentDone;
};

Ext.define('TSTreeModel',{
    extend: 'Ext.data.Model',
    fields: [
        { name: 'FormattedID', type: 'String' },
        { name: 'Name', type:'String' },
        { name: 'ScheduleState', type:'String' },
        { name: 'PlannedStartDate', type: 'Date' },
        { name: 'PlannedEndDate', type: 'Date' },
        { name: '_type', type:'String' },
        { name: '__original_value', type: 'auto' },
        { name: '__rollup', type:'Float' },
        { name: '__accepted_rollup', type: 'Float' },
        { name: '__calculated_delta', type: 'Float', convert: convertDelta },
        { name: '__calculated_remaining', type:'Float', convert: convertRemaining },
        { name: '__progress_by_original', type: 'Float', convert: convertProgressByOriginal },
        { name: '__progress_by_rollup', type: 'Float', convert: convertProgressByRollup },
        { name: '__is_top_pi', type: 'Boolean', defaultValue: false }
    ],
    set: function (fieldName, newValue) {
        var me = this,
            data = me[me.persistenceProperty],
            fields = me.fields,
            modified = me.modified,
            single = (typeof fieldName == 'string'),
            currentValue, field, idChanged, key, modifiedFieldNames, name, oldId,
            newId, value, values;

        if (single) {
            values = me._singleProp;
            values[fieldName] = newValue;
        } else {
            values = fieldName;
        }

        for (name in values) {
            if (values.hasOwnProperty(name)) {
                value = values[name];

                if (fields && (field = fields.get(name)) && field.convert) {
                    value = field.convert(value, me);
                }

                currentValue = data[name];
                if (me.isEqual(currentValue, value)) {
                    continue; // new value is the same, so no change...
                }

                data[name] = value;
                (modifiedFieldNames || (modifiedFieldNames = [])).push(name);

                if (field && field.persist) {
                    if (modified.hasOwnProperty(name)) {
                        if (me.isEqual(modified[name], value)) {
                            // The original value in me.modified equals the new value, so
                            // the field is no longer modified:
                            delete modified[name];

                            // We might have removed the last modified field, so check to
                            // see if there are any modified fields remaining and correct
                            // me.dirty:
                            me.dirty = false;
                            for (key in modified) {
                                if (modified.hasOwnProperty(key)){
                                    me.dirty = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        me.dirty = true;
                        modified[name] = currentValue;
                        /* 
                         * Overridden here to recalculate the delta
                         */
                        if ( name == "__accepted_rollup" || name == "__original_value" ) {
                            var done = this.get('__accepted_rollup') || 0;
                            var original = this.get('__original_value') || 0;
                            var delta = done - original;
                            modifiedFieldNames.push( this.set("__calculated_delta", delta));
                        }
                        if ( name == "__accepted_rollup" || name == "__rollup" ) {
                            var done = this.get('__accepted_rollup') || 0;
                            var total = this.get('__rollup') || 0;
                            var delta = total-done;
                            modifiedFieldNames.push( this.set("__calculated_remaining", delta));
                        }
                    }
                }

                if (name == me.idProperty) {
                    idChanged = true;
                    oldId = currentValue;
                    newId = value;
                }
            }
        }

        if (single) {
            // cleanup our reused object for next time... important to do this before
            // we fire any events or call anyone else (like afterEdit)!
            delete values[fieldName];
        }

        if (idChanged) {
            me.fireEvent('idchanged', me, oldId, newId);
        }

        if (!me.editing && modifiedFieldNames) {
            me.afterEdit(modifiedFieldNames);
        }

        return modifiedFieldNames || null;
    }
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
        {xtype:'container',itemId:'message_box',tpl:'Hello, <tpl>{_refObjectName}</tpl>'},
        {xtype:'container',itemId:'display_box'} 
        /*,
        {xtype:'tsinfolink'}
        */
    ],
    iterations: [],
    completed_state_values: ['Accepted','Completed'],
    completed_state_field: 'ScheduleState',
    estimate_field: 'PlanEstimate',
    launch: function() {
        
        this.cb_release = this.down('#display_box').add({
            xtype: 'rallyreleasecombobox',
            scope:this,
            startDateField: 'ReleaseStartDate',
            endDateField: 'ReleaseDate',
            listeners: {
                scope: this,
                change: this._updateRelease
            } 
        });
   },
   _updateRelease: function(cb, newValue, oldValue){
       this.logger.log('_updateRelease', newValue, oldValue);
       var record = cb.findRecordByValue(newValue);
       var selectedReleases = [record.getId()];
       var releaseStartDate = record.get('ReleaseStartDate');
       var releaseEndDate = record.get('ReleaseDate');
       var me = this; 

       //Load Iterations for the selected release 
       this.iterations = []; 
       this._loadIterations(releaseStartDate,releaseEndDate).then({
           scope:this,
           success: function(data){
               Ext.Array.each(data,function(rec){
                   me.iterations.push([rec.getData().ObjectID,rec.getData().Name]);
               });
           }, 
           failure: function(error){
               alert('Error loading Iterations:'  + error.toString());
           }
       });
       
       
       atDate = "current";  
       var me = this;
       //Retrieve the stories for the release and calculate the rollups
       Ext.create('Rally.data.lookback.SnapshotStore', {
           scope: this,
           listeners: {
               scope: this,
               load: function(store, data, success){
                   me._buildTreeStore(data);
               }
           },
           autoLoad: true,
           fetch: ['Name','FormattedID','ObjectID','_ItemHierarchy',me.estimate_field,me.completed_state_field,'_TypeHierarchy','Iteration','PortfolioItem'],
           hydrate: ['ScheduleState','_TypeHierarchy'],
           filters: [{
                     property: '_TypeHierarchy',
                     operator: 'in',
                     value: ['HierarchicalRequirement','PortfolioItem']
           },{  //TODO:  May need to get all releases for a selected release over multiple teams 
               property: 'Release',
               operator: 'in',
               value: selectedReleases
           },{
               property: '__At',
               value: atDate
           }]
       });      
       
   
    },
    _getTopLevelObjectIds: function(data){
        this.logger.log('_getTopLevelObjectIds');
        var topLevelObjectIDs = []; 
        
        Ext.Array.each(data, function(data_obj){
            var topObjID = data_obj.data['_ItemHierarchy'][0];
            if (!Ext.Array.contains(topLevelObjectIDs, topObjID)){
                topLevelObjectIDs.push(topObjID);
            }
        });
        return topLevelObjectIDs;
    },
    _loadDetailData: function(topLevelIDs, asOfDate){
        this.logger.log('_loadDetailData');
        var me = this;
        me.logger.log('_loadDetailData',topLevelIDs);
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.lookback.SnapshotStore', {
            scope: this,
            listeners: {
                scope: this,
                load: function(store, data, success){
                    if (success){
                        me.logger.log(data);
                        deferred.resolve(data);
                    } else {
                        me.logger.log('_loadDetailData.failure');
                        deferred.reject('Error loading details for top level object ids');
                    }
                }
            },
            autoLoad: true,
            fetch: ['Name','FormattedID','ObjectID','_ItemHierarchy',me.estimate_field,me.completed_state_field,'Iteration','Release','DirectChildrenCount','Children','UserStories','_TypeHierarchy'],
            hydrate: [me.completed_state_field,'_TypeHierarchy'],
            filters: [{
                      property: '_ItemHierarchy',
                      operator: 'in',
                      value: topLevelIDs
            },{
                property: '__At',
                value: "current"
            }]
        });      
        return deferred.promise; 
    },
    _getRollupEstimatedField: function(index){
        return '_RollupEstimated_' + this._getIterationName(index);
    },
    _getRollupCompletedField: function(index){
        return '_RollupCompleted_' + this._getIterationName(index);
    },
    _getIterationName: function(index){
        return 'Iteration ' + this.iterations[index][1];
    },
    _getIterationIndex: function(iteration_id) {
        for (var i=0; i<this.iterations.length; i++){
            if (this.iterations[i][0] == iteration_id){
                return i;
            }
        }
        return -1;
    }, 
    _populateObject: function(id,data_hash){
        this.logger.log('_populateObject', id);
        var me = this;
        var tree_obj=[];
        var obj = data_hash[id];

        tree_obj['__Type'] = obj.get('_TypeHierarchy').slice(-1)[0];
        tree_obj['ObjectID'] = id;
        tree_obj['FormattedID'] = obj.get('FormattedID');
        tree_obj['Name']=obj.get('Name');

        //initialize the rollups
        var iteration = obj.get('Iteration') || 0;
        var iteration_index = me._getIterationIndex(iteration);
        
        for (var i=0; i< me.iterations.length; i++){
            tree_obj[me._getRollupCompletedField(i)] = 0;
            tree_obj[me._getRollupEstimatedField(i)] = 0;
            tree_obj[me._getIterationName(i).toString()] = me._getIterationName(i).toString();
            if (i == iteration_index) {
                var state = obj.get(me.completed_state_field) || "";    
                var estimate = obj.get(me.estimate_field) || 0;
                tree_obj[me._getRollupEstimatedField(i)] = estimate;
                if (Ext.Array.contains(me.completed_state_values, state)){
                    tree_obj[me._getRollupCompletedField(i)] = estimate;
                }
            }
        }

        tree_obj['_display'] = false; 
        if (obj.get('PortfolioItem') > 0 || tree_obj['__Type'].toString().match(/PortfolioItem/i)){
            tree_obj['_display'] = true;
        }
       
       var children = me._getChildren(id, data_hash);
       console.log(children);
       tree_obj['children'] = children;
       console.log(tree_obj['Name'],tree_obj['FormattedID'],obj.get('DirectChildrenCount'));
       if (obj.get('DirectChildrenCount')>0){
            tree_obj['leaf'] = false;

            console.log('after children' , tree_obj['children'], tree_obj);
            //Calculate Rollups
            
//            Ext.Array.each(tree_obj['children'], function(child){
//            var cumulative_estimate = 0;
//            var cumulative_completed = 0; 
//                for (var i=0; i<me.iterations.length; i++){
//                    var sum = tree_obj[me._getRollupEstimatedField(i)] + child[me._getRollupEstimatedField(i)];
//                    cumulative_estimate = cumulative_estimate + sum; 
//                    tree_obj[me._getRollupEstimatedField(i)] = cumulative_estimate;//sum;
//
//                    sum = tree_obj[me._getRollupCompletedField(i)] + child[me._getRollupCompletedField(i)];
//                    cumulative_completed = cumulative_completed + sum;  
//                    tree_obj[me._getRollupCompletedField(i)] = cumulative_completed; //sum;
//                    console.log(me._getIterationName(i),tree_obj['Name'], tree_obj['FormattedID'], tree_obj[me._getRollupEstimatedField(i)],tree_obj[me._getRollupCompletedField(i)],child['Name'], child[me._getRollupEstimatedField(i)],child[me._getRollupCompletedField(i)]);
//                }
//            });
        } else {
            tree_obj['leaf'] = true;
        }
        this._calculateRollups(tree_obj,'iteration');
        return tree_obj; 
    },
    _getChildren: function(parent_id,data_hash){
        this.logger.log('_getChildren',parent_id);
        var children = [];
        var me= this;
        
        var obj = data_hash[parent_id];
        if (!(obj && obj.get('DirectChildrenCount') > 0)){
            return children;
        }
        
        var child_obj_ids = [];
        if (obj.get('Children') && obj.get('Children').length > 0){
            child_obj_ids = obj.get('Children');
        } else if (obj.get('UserStories') && obj.get('UserStories').length > 0){
            child_obj_ids = obj.get('UserStories');
        }
        console.log('_getChildren', child_obj_ids);
        Ext.Array.each(child_obj_ids, function(child_id){
            var child_obj = me._populateObject(child_id,data_hash);
            children.push(child_obj);
        });
        
        return children; 
    },
    _buildTreeNodeDataStructure: function(detail_data,topLevelObjectIds){
        this.logger.log('_buildTreeNodeDataStructure',detail_data,topLevelObjectIds);
        var me = this; 
        
        var data_hash = [];
        Ext.Array.each(detail_data, function(detail){
            data_hash[detail.get('ObjectID')] = detail; 
        });
        
        var topLevelObjects = [];
        Ext.Array.each(topLevelObjectIds, function(top_id){
          topLevelObject = me._populateObject(top_id,data_hash);
          topLevelObjects.push(topLevelObject);
        });
        this.logger.log('_buildTreeNodeDataStructure',topLevelObjects);
        return topLevelObjects;
    },
    _calculateRollups: function(object_tree, calculation){
        calculation='total';
        var cumulative_completed = 0; //cumulative total for each  iteration 
        var me = this;
        
        var children = object_tree['children'];
        if (!(children && children.length > 0)) {
            return; 
        }

           // me._calculateRollups(child);
            cumulative_estimated = 0;
            total_estimated = 0;
            for(var i=0; i<me.iterations.length; i++){
                var iteration_estimated = 0;
                var iteration_completed=0;
                Ext.Array.each(children, function(child){
                    if (child.leaf == false || calculation == 'iteration'){
                        iteration_estimated = iteration_estimated + child[me._getRollupEstimatedField(i)];
                        iteration_completed = iteration_completed + child[me._getRollupCompletedField(i)];

                        object_tree[me._getRollupEstimatedField(i)] = iteration_estimated;
                        object_tree[me._getRollupCompletedField(i)] = iteration_completed;
                    } else {  // for leaf children when doing cumulative roll ups
                        cumulative_estimated = cumulative_estimated + child[me._getRollupEstimatedField(i)];
                        cumulative_completed = cumulative_completed + child[me._getRollupCompletedField(i)];
                        
                        object_tree[me._getRollupEstimatedField(i)] = cumulative_estimated;
                        object_tree[me._getRollupCompletedField(i)] = cumulative_completed;
                    }                    
                });
                if (i==me.iterations.length-1) total_estimated = total_estimated + object_tree[me._getRollupEstimatedField(i)];
            }
            console.log(object_tree['Name'],'toal_estimated',total_estimated);
         
        if (calculation == 'total'){
            for (var i=0; i< me.iterations.length; i++){
                object_tree[me._getRollupEstimatedField(i)]=total_estimated;
            }
        }

        
    },
    _defineFieldModel: function(){
        this.logger.log('_defineFieldModel');
       // extend the model to add fields
        var me = this; 
        var fields = [];
        
        fields.push({ name:'FormattedID', type: 'String' });
        fields.push({name:'Name', type:'String' });

        for (var i=0; i<me.iterations.length; i++) {
            fields.push({name: me._getIterationName(i), type:'String'});
            fields.push({name: me._getRollupEstimatedField(i), type:'Float'});
            fields.push({name: me._getRollupCompletedField(i), type:'Float'});
        }
            
        var model = {
            extend: 'Ext.data.Model',
            fields: fields
        };
        me.logger.log("Made a model using these fields: ", fields);
        return model; ;
    },
    
    _buildTreeStore: function(data){
        this.logger.log('_buildTreeStore');
        var me = this;  
        var topLevelObjects = this._getTopLevelObjectIds(data);
        console.log('_buildTreeStore',topLevelObjects,data);
        var tree_nodes = {};
        
        this._loadDetailData(topLevelObjects, new Date()).then({
            scope:this,
            success: function(data){
            
               tree_nodes = me._buildTreeNodeDataStructure(data,topLevelObjects);
               var model = me._defineFieldModel();
               Ext.define('TSTreeModelWithIterations', model);        
               
               var treeStore = Ext.create('Ext.data.TreeStore',{
                   model: TSTreeModelWithIterations,
                   root: {
                       expanded: false,
                       children: tree_nodes
                       }
               });
               console.log('before buildtree');
               me._buildTree(treeStore); 
            },
            failure: function(error){
                
            }
        });
        
    },
    
    _buildTree: function(tree_store){
        this.logger.log('_buildTree');
        var me = this;
        console.log(tree_store);

        var tree_columns = me._getTreeColumns();
        me.down('#display_box').add({
            scope:this,
            xtype:'treepanel',
            store: tree_store,
            rootVisible: false,
            autoLoad: true,
            columns: tree_columns
        });
        
    },
   _getTreeColumns: function(){
        this.logger.log('_getTreeColumns');
        var me = this;
        me.logger.log("_getColumns");
        
        var columns = [
            {
                xtype: 'treecolumn',
                text: 'FormattedID',
                dataIndex: 'FormattedID',
                itemId: 'tree_column',
                renderer: function(value,meta_data,record) {
                    return value + ": " + record.get('Name');
                },
                width: 200
            }];
        for (var i=0; i< me.iterations.length; i++){
            var column_header = me._getIterationName(i);
            var column_index = me._getIterationName(i);

            var iteration_column = {
                    dataIndex: column_index,
                    text: column_header,
                    itemId:column_index + '_column',
                    width: 100,
                    renderer: function(value,meta_data,record) {
                        console.log (record.get('Name'),record.get('_RollupEstimated_' + value),record.get('_RollupCompleted_' + value))
                        return Ext.create('Rally.technicalservices.ProgressBarTemplate',{
                                numeratorField: '_RollupCompleted_' + value,
                                denominatorField: '_RollupEstimated_' + value,
                                percentDoneName: ''
                            }).apply(record.getData());
                           
//                            if (record.get('_RollupEstimated_' + value) > 0 ){
//                            return Math.round(record.get('_RollupCompleted_' + value)/record.get('_RollupEstimated_' + value) * 100) + '%';
//                        } else {
//                            return ('N/A');
//                        }
                    },
                    menuDisabled: true
                };
                columns.push(iteration_column);
        }
        me.logger.log("Making Columns ", columns);
        return columns;        
    },
    _loadIterations: function(releaseStartDate, releaseEndDate){
        this.logger.log('_loadIterations');
        var deferred = Ext.create('Deft.Deferred');

        console.log(releaseStartDate, releaseEndDate);
        Ext.create('Rally.data.wsapi.Store',{
            model: 'Iteration',
            autoLoad: true,
            listeners: {
                scope:this,
                load: function(store, data, success){
                    if (success){
                        this.logger.log('Success loading Iterations', data);
                        deferred.resolve(data);                        
                    } else {
                        this.logger.log('Failed loading Iterations');
                        deferred.reject();
                    }
                }
            },
            fetch: ['ObjectID','Name','StartDate','EndDate'] ,
            filters: [{
                property: 'EndDate',
                operator: '>',
                value: releaseStartDate.toISOString()
            },{
                property: 'StartDate',
                operator: '<',
                value: releaseEndDate.toISOString()
            }],
            sorters: [{
                property: 'StartDate',
                direction: 'ASC'
            }]
            
        });
        return deferred.promise; 
    }
        
   

});

            
               Rally.launchApp('CustomApp', {
                   name: 'pi-progress-tree'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}

.x-tree-icon { display: none !important; }

.x-column-header {
    border-bottom-color: rgb(34, 34, 34);
    border-bottom-style: solid;
    border-bottom-width: 4px;
    border-top-style: none;
}
.x-panel-default, .x-grid-header-ct, .yes-harmonized .x-panel-body-default  {
    border-color: #fff;
}

.x-grid-cell-inner {
    font-family: NotoSans, Helvetica, Arial;
    font-size: 12px;
}

    
.yes-harmonized .rally-grid.x-grid .x-grid-header-ct .x-box-inner {
    border-bottom: none;
}
   body {
            overflow-y: auto !important;
        }
        
        .app {
            margin: 10px 30px;
        }
        
        .app > .leftSide {
            float: left;
            width: 45%;
        }
        
        .app > .rightSide {
            float: right;
            width: 45%;
        }
        
        h1 {
            font-size: 14px;
            margin: 5px;
        }
        
        .grayLabel {
            color: #888;
            margin: 5px 15px;
        }
        
        
        .percentDoneContainer {
            height: 15px;
            line-height: 15px;
        }
        
        .planEstimate {
            width: 20px;
            height: 20px;
            border: 1px dotted #5C9ACB;
            text-align: center;
            margin-right: 4px;
            position: absolute;
            top: 5px;
            right: 3px;
        }   
    </style>

</head>
<body></body>
</html>