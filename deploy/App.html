<!DOCTYPE html>
<html>
<head>
    <title>pi-progress-tree</title>
    <!--  (c) 2014 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Thu Jul 10 2014 08:23:21 GMT-0600 (MDT) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Thu Jul 10 2014 08:23:21 GMT-0600 (MDT)";
        var CHECKSUM = 63700944739;
    </script>
    
    <script type="text/javascript" src="/apps/2.0rc2/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     title: "Build Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>--</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});

/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

Ext.define('Rally.technicalservices.ProgressBarTemplate', {
    requires: [],
    extend: 'Ext.XTemplate',

    config: {
        /**
         * @cfg {String} width define a width if necessary to fit where it's being used
         */
        width: '100%',
        /**
         * @cfg {String} height define a height if necessary to fit where it's being used
         */
        height: '20px',
        /**
         * @cfg {String} numeratorField will divide numeratorField value / denominatorField value to 
         * get percent done
         */
        numeratorField: 'percentDone',
        /**
         * @cfg {String} denominatorField will divide numeratorField value / denominatorField value to 
         * get percent done
         */
        denominatorField: 'percentDone',
        /**
         * @cfg {Function} showDangerNotificationFn A function that should return true to show a triangle in the top right to denote something is missing.
         * Defaults to:
         *      function(){ return false; }
         */
        showDangerNotificationFn: function() {
            return false;
        },

        /**
         * @cfg {Function} (required)
         * A function that returns the color for the percent done bar in hex
         */
        calculateColorFn: function(recordData) {            
            var numerator = recordData[this.config.numeratorField] || 0;
            var denominator = recordData[this.config.denominatorField] || 0;
            
            var percentDone = 0;
            
            if ( denominator > 0 ) {
                percentDone = numerator / denominator;
            }
                
            var color = '#cff';
            return color;
//            var start_date = recordData['PlannedStartDate'] ;
//            if ( start_date === null ) { 
//                start_date = new Date();
//            }
//            var end_date = recordData['PlannedEndDate'];
//            
//            if ( end_date !== null ) {
//                var color = Rally.util.HealthColorCalculator.calculateHealthColor({
//                    startDate: start_date,
//                    endDate: end_date,
//                    asOfDate: new Date(),
//                    percentComplete: percentDone
//                }).hex;
//            }
            

        },

        /**
         * @cfg {Boolean} (optional)
         * A boolean that indicates whether the progress bar is clickable
         */
        isClickable: false,

        /**
         * @cfg {Boolean} If the percent done is 0%, do not show the bar at all
         */
        showOnlyIfInProgress: false,

        /**
         * @cfg {Function}
         * A function that returns the text to show in the progress bar.
         * Defaults to a function that returns the percentage complete.
         */
        generateLabelTextFn: function (recordData) {
            return this.calculatePercent(recordData) + '%';
        }
    },

    constructor: function(config) {
        this.initConfig(config);
        config = this.config;
        var templateConfig = [
            '<tpl if="this.shouldShowPercentDone(values)">',
                '<div class="progress-bar-container field-{[this.getDenominatorField()]} {[this.getClickableClass()]} {[this.getContainerClass(values)]}" style="{[this.getDimensionStyle()]}">',
                    '<div class="progress-bar" style="background-color: {[this.calculateColor(values)]}; width: {[this.calculateWidth(values)]}; "></div>',
                    '<tpl if="this.showDangerNotification(values)">',
                        '<div class="progress-bar-danger-notification"></div>',
                    '</tpl>',
                    '<div class="progress-bar-label">',
                        '{[this.generateLabelText(values)]}',
                    '</div>',
                '</div>',
            '</tpl>',
            {
                shouldShowPercentDone: function(recordData) {
                    return true;
                },
                getContainerClass: function(recordData) {
                    if (recordData && recordData.FormattedID) {
                        return recordData.FormattedID + '-' + config.denominatorField;
                    }
                    return '';
                },
                getClickableClass: function(){
                    return config.isClickable ? 'clickable' : '';
                },
                getDimensionStyle: function(){
                    return 'width: ' + config.width + '; height: ' + config.height + '; line-height: ' + config.height;
                },
                calculateWidth: function (recordData) {
                    var percentDone = this.calculatePercent(recordData);
                    return percentDone > 100 ? '100%' : percentDone + '%';
                },
                calculatePercent: function (recordData) {
                    var numerator = recordData[this.config.numeratorField] || 0;
                    var denominator = recordData[this.config.denominatorField] || 0;
                    
                    var percentDone = 0;
                    if ( denominator > 0 ) {
                        percentDone = numerator / denominator;
                    }
                    return Math.round(percentDone * 100);
                },
                generateLabelText: config.generateLabelTextFn,
                calculateColor: config.calculateColorFn,
                showDangerNotification: config.showDangerNotificationFn
            }];

        return this.callParent(templateConfig);

    }
});

var convertDelta = function(value,record) {
    var done = record.get('__accepted_rollup') || 0;
    var original = record.get('__original_value');
    if ( original || original === 0 ) {
        return done - original;
    }
    return "";
};
var convertRemaining = function(value,record) {
    var done = record.get('__accepted_rollup') || 0;
    var total = record.get('__rollup') || 0;
    var delta = total-done;
    return delta;
};

var convertProgressByOriginal = function(value,record) {
    var numerator = record.get('__accepted_rollup') || 0;
    var denominator = record.get('__original_value') || 0;
    var percentDone = 0;
    if ( denominator > 0 ) {
        percentDone = numerator / denominator;
    }
    return percentDone;
};

var convertProgressByRollup = function(value,record) {
    var numerator = record.get('__accepted_rollup') || 0;
    var denominator = record.get('__rollup') || 0;
    var percentDone = 0;
    if ( denominator > 0 ) {
        percentDone = numerator / denominator;
    }
    return percentDone;
};

Ext.define('TSTreeModel',{
    extend: 'Ext.data.Model',
    fields: [
        { name: 'FormattedID', type: 'String' },
        { name: 'Name', type:'String' },
        { name: 'ScheduleState', type:'String' },
        { name: 'PlannedStartDate', type: 'Date' },
        { name: 'PlannedEndDate', type: 'Date' },
        { name: '_type', type:'String' },
        { name: '__original_value', type: 'auto' },
        { name: '__rollup', type:'Float' },
        { name: '__accepted_rollup', type: 'Float' },
        { name: '__calculated_delta', type: 'Float', convert: convertDelta },
        { name: '__calculated_remaining', type:'Float', convert: convertRemaining },
        { name: '__progress_by_original', type: 'Float', convert: convertProgressByOriginal },
        { name: '__progress_by_rollup', type: 'Float', convert: convertProgressByRollup },
        { name: '__is_top_pi', type: 'Boolean', defaultValue: false }
    ],
    set: function (fieldName, newValue) {
        var me = this,
            data = me[me.persistenceProperty],
            fields = me.fields,
            modified = me.modified,
            single = (typeof fieldName == 'string'),
            currentValue, field, idChanged, key, modifiedFieldNames, name, oldId,
            newId, value, values;

        if (single) {
            values = me._singleProp;
            values[fieldName] = newValue;
        } else {
            values = fieldName;
        }

        for (name in values) {
            if (values.hasOwnProperty(name)) {
                value = values[name];

                if (fields && (field = fields.get(name)) && field.convert) {
                    value = field.convert(value, me);
                }

                currentValue = data[name];
                if (me.isEqual(currentValue, value)) {
                    continue; // new value is the same, so no change...
                }

                data[name] = value;
                (modifiedFieldNames || (modifiedFieldNames = [])).push(name);

                if (field && field.persist) {
                    if (modified.hasOwnProperty(name)) {
                        if (me.isEqual(modified[name], value)) {
                            // The original value in me.modified equals the new value, so
                            // the field is no longer modified:
                            delete modified[name];

                            // We might have removed the last modified field, so check to
                            // see if there are any modified fields remaining and correct
                            // me.dirty:
                            me.dirty = false;
                            for (key in modified) {
                                if (modified.hasOwnProperty(key)){
                                    me.dirty = true;
                                    break;
                                }
                            }
                        }
                    } else {
                        me.dirty = true;
                        modified[name] = currentValue;
                        /* 
                         * Overridden here to recalculate the delta
                         */
                        if ( name == "__accepted_rollup" || name == "__original_value" ) {
                            var done = this.get('__accepted_rollup') || 0;
                            var original = this.get('__original_value') || 0;
                            var delta = done - original;
                            modifiedFieldNames.push( this.set("__calculated_delta", delta));
                        }
                        if ( name == "__accepted_rollup" || name == "__rollup" ) {
                            var done = this.get('__accepted_rollup') || 0;
                            var total = this.get('__rollup') || 0;
                            var delta = total-done;
                            modifiedFieldNames.push( this.set("__calculated_remaining", delta));
                        }
                    }
                }

                if (name == me.idProperty) {
                    idChanged = true;
                    oldId = currentValue;
                    newId = value;
                }
            }
        }

        if (single) {
            // cleanup our reused object for next time... important to do this before
            // we fire any events or call anyone else (like afterEdit)!
            delete values[fieldName];
        }

        if (idChanged) {
            me.fireEvent('idchanged', me, oldId, newId);
        }

        if (!me.editing && modifiedFieldNames) {
            me.afterEdit(modifiedFieldNames);
        }

        return modifiedFieldNames || null;
    }
});
Ext.define('CustomApp', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [
         {xtype:'container',itemId:'display_box'} 
        /*,
        {xtype:'tsinfolink'}
        */
    ],
    calculation_type: 'total', //'total', //cumulative, iteration
    iterations: [],
    completed_state_values: ['accepted','completed'],
    completed_state_field: 'ScheduleState',
    estimate_field: 'PlanEstimate',
    launch: function() {
        this.logger.log('Project',this.getContext().getProject());
        this.cb_release = this.down('#display_box').add({
            xtype: 'rallyreleasecombobox',
            scope:this,
            startDateField: 'ReleaseStartDate',
            endDateField: 'ReleaseDate',
            storeConfig: {context: {projectScopeDown: false},
                          fetch: ['ReleaseStartDate','ReleaseDate','ObjectID','Project','State','Name']},
            listeners: {
                scope: this,
                change: this._updateRelease
            } 
        });
        
   },
   _getReleaseStartDate: function(){
       return this.cb_release.getRecord().get('ReleaseStartDate').toISOString();
   },

   _getReleaseEndDate: function(){
       return this.cb_release.getRecord().get('ReleaseDate').toISOString();
   },
   
   _updateRelease: function(cb, newValue, oldValue){
       this.logger.log('_updateRelease', newValue, oldValue);
       var record = cb.findRecordByValue(newValue);
       var projectRef = record.get('Project')._ref;
       var selectedReleaseIds = [record.get('ObjectID')];

       var me = this; 

           atDate = "current";  
           var me = this;
           //Retrieve the stories for the release and calculate the rollups
           Ext.create('Rally.data.lookback.SnapshotStore', {
               scope: this,
               listeners: {
                   scope: this,
                   load: function(store, data, success){
                       me.logger.log('_updateRelease returned data',data);
                       me._buildTreeStore(data, selectedReleaseIds);
                   }
               },
               autoLoad: true,
               fetch: ['Name','FormattedID','ObjectID','_ItemHierarchy','_TypeHierarchy','Release'],
               hydrate: ['_TypeHierarchy'],
               filters: [{
                         property: '_TypeHierarchy',
                         operator: 'in',
                        //TODO: this needs to be configurable for the name for USPTO
                         value: ['PortfolioItem/Epic']
               },{  //TODO:  May need to get all releases for a selected release over multiple teams 
                   property: 'Release',
                   operator: 'in',
                   value: selectedReleaseIds
               },{
                   property: '__At',
                   value: atDate
               }]
           });                     
    },
    
    _getTopLevelObjectIds: function(data){
        this.logger.log('_getTopLevelObjectIds');
        var topLevelObjectIDs = []; 
        
        Ext.Array.each(data, function(data_obj){
            var topObjID = data_obj.data['_ItemHierarchy'][0];
            if (!Ext.Array.contains(topLevelObjectIDs, topObjID)){
                topLevelObjectIDs.push(topObjID);
            }
        });
        return topLevelObjectIDs;
    },
    _loadDetailData: function(topLevelObjectIds, asOfDate){
        this.logger.log('_loadDetailData', topLevelObjectIds);
        var me = this;

        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.lookback.SnapshotStore', {
            scope: this,
            listeners: {
                scope: this,
                load: function(store, data, success){
                    if (success){
                        me.logger.log('_loadDetailData',data.length);
                        deferred.resolve(data);
                    } else {
                        me.logger.log('_loadDetailData failure');
                        deferred.reject('Error loading details for portfolio items');
                    }
                }
            },
            autoLoad: true,
            fetch: ['Name','FormattedID','ObjectID','_ItemHierarchy',me.estimate_field,me.completed_state_field,'Iteration','Release','DirectChildrenCount','Children','UserStories','_TypeHierarchy'],
            hydrate: [me.completed_state_field,'_TypeHierarchy'],
            find: {
                "_ItemHierarchy": {$in: topLevelObjectIds},
                "_TypeHierarchy": {$in: ['PortfolioItem']},
                "__At": "current"
            }
        });      
        return deferred.promise; 
    },
    _loadStoryDetailData: function(epics, asOfDate){
        this.logger.log('_loadStoryDetailData', epics);
        var me = this;

        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.lookback.SnapshotStore', {
            scope: this,
            listeners: {
                scope: this,
                load: function(store, data, success){
                    if (success){
                        me.logger.log('_loadStoryDetailData',data.length);
                        deferred.resolve(data);
                    } else {
                        me.logger.log('_loadStoryDetailData failure');
                        deferred.reject('Error loading details for stories');
                    }
                }
            },
            autoLoad: true,
            fetch: ['Name','FormattedID','ObjectID','_ItemHierarchy',me.estimate_field,me.completed_state_field,'Iteration','Release','Epic','Feature','PortfolioItem','Parent','_TypeHierarchy'],
            hydrate: [me.completed_state_field,'_TypeHierarchy'],
            find: {
                "_ItemHierarchy": {$in: epics},
                "_TypeHierarchy": {$in: ['HierarchicalRequirement']},
                "__At": asOfDate,
                "DirectChildrenCount": 0  //return leaf node stories only 
            }
        });      
        return deferred.promise; 
    },
    _getRollupEstimatedField: function(index){
        return '_RollupEstimated_' + this._getIterationKey(index);
    },
    _getRollupCompletedField: function(index){
        return '_RollupCompleted_' + this._getIterationKey(index);
    },
    _getIterationName: function(index){
        return  this.iterations[index][3] + "<br>" + this.iterations[index][1];
    },
    _getIterationKey: function(index){
        return 'I' + this.iterations[index][0];
    },
    _getIterationIndex: function(iteration_id) {
        for (var i=0; i<this.iterations.length; i++){
            if (this.iterations[i][0] == iteration_id){
                return i;
            }
        }
        return -1;
    }, 
    _getCalculationType: function(){
        return this.calculation_type;
    },
    _populateObject: function(id,data_hash, story_data){
        this.logger.log('_populateObject', id, data_hash[id]);
        var me = this;
        var obj = data_hash[id];
        if (obj == undefined){
            return obj;
        }

        var tree_obj=[];
        tree_obj['__Type'] = obj.get('_TypeHierarchy').slice(-1)[0];
        tree_obj['ObjectID'] = id;
        tree_obj['FormattedID'] = obj.get('FormattedID');
        tree_obj['Name']=obj.get('Name');

        //initialize the rollups
        for (var i=0; i< me.iterations.length; i++){
            tree_obj[me._getRollupCompletedField(i)] = 0;
            tree_obj[me._getRollupEstimatedField(i)] = 0;
            tree_obj[me._getIterationKey(i).toString()] = me._getIterationKey(i).toString();
        }
        
        var children = me._getChildren(id, data_hash,story_data);
        tree_obj['children'] = children;
        if (children.length == 0){
            tree_obj['leaf'] =  true; 
        }

        if (tree_obj['__Type'] == 'PortfolioItem/Epic'){
            tree_obj = this._rollupStories(story_data,tree_obj);
            tree_obj['leaf'] =  true; 
        }
        
        this._calculateRollups(tree_obj);
       
        return tree_obj; 
    },
    _getChildren: function(parent_id,data_hash,story_data){
        this.logger.log('_getChildren',parent_id);
        var children = [];
        var me= this;
        
        var obj = data_hash[parent_id];
        if (obj == undefined){
            return children;
        }
        
        var child_obj_ids = [];
        console.log('childrenx',obj.get('FormattedID'),obj.get('Children'));
       if (obj.get('Children') && obj.get('Children').length > 0){
            child_obj_ids = obj.get('Children');
            Ext.Array.each(child_obj_ids, function(child_id){
                var child_obj = me._populateObject(child_id,data_hash,story_data);
                if (child_obj != undefined){
                    children.push(child_obj);
                }
            });
        } 
       
        return children; 
    },

    _rollupStories: function(story_data, obj){
        //populates the lowest level PIs with rollups 
        var me = this;
        me.logger.log('_rollupStories', obj['ObjectID'], obj['FormattedID'],story_data);
        var total_estimated = 0;
        Ext.Array.each(story_data, function(sd){
            var sd_data = sd.getData();
            var belongsToFeature = Ext.Array.contains(sd_data._ItemHierarchy, obj['ObjectID']);
            if (belongsToFeature){
                var iteration_index = me._getIterationIndex(sd_data.Iteration);  //Move this down below if we want all estimates for feature, even if they aren't in current iterations
                if (iteration_index >= 0 ){
                    total_estimated = total_estimated + sd_data.PlanEstimate;
                    if (me._isCompleted(sd_data.ScheduleState)){
                        obj[me._getRollupCompletedField(iteration_index)] = obj[me._getRollupCompletedField(iteration_index)] + sd_data.PlanEstimate;
                   }
                }
            }
        });

        //This makes the denominator the total rollup for the entire release for all items...
        var cumulative_completed = 0;  
        for (var i=0; i< me.iterations.length; i++){
            cumulative_completed = cumulative_completed + obj[me._getRollupCompletedField(i)];
            obj[me._getRollupEstimatedField(i)]=total_estimated;
            obj[me._getRollupCompletedField(i)]= cumulative_completed;
            console.log('Epic Rollups',obj['FormattedID'],me._getIterationKey(i),obj[me._getRollupEstimatedField(i)],obj[me._getRollupCompletedField(i)]);
        }
        
        return obj;
   },
   _isCompleted: function(state){
       return (Ext.Array.contains(this.completed_state_values, state.toLowerCase()))
   },
    _buildTreeNodeDataStructure: function(pi_data,story_data,topLevelObjectIds, epics){
        this.logger.log('_buildTreeNodeDataStructure',pi_data,story_data);

        var me = this; 
        
        //Get an array of all relevant portfolio items.  Relevant means portfolio items which are associated with the 
        //selected release or an ancestor of the pis associated with the selected release.  
        var filtered_obj_ids = [];
        Ext.Array.each(pi_data,function(pi){
            if (Ext.Array.contains(epics,pi.get('_ItemHierarchy').slice(-1)[0])){
                Ext.Array.each(pi.get('_ItemHierarchy'),function(ih){
                    if (!Ext.Array.contains(filtered_obj_ids,ih)){
                        filtered_obj_ids.push(ih);
                    }
                });
            }
        });

        //Add relevant Portofolio items to the data hash by verifying that they exist in the list of ancestor PIs  
        var data_hash = [];
        Ext.Array.each(pi_data, function(detail){
            var obj_id = detail.get('ObjectID');
            if (Ext.Array.contains(filtered_obj_ids,obj_id)){
                data_hash[obj_id] = detail;
            }
        });
        
        var topLevelObjects = [];
        Ext.Array.each(topLevelObjectIds, function(top_id){
          topLevelObject = me._populateObject(top_id,data_hash, story_data);
           if (topLevelObject){
              
              topLevelObjects.push(topLevelObject);
          }
        });
        
        this.logger.log('_buildTreeNodeDataStructure',topLevelObjects);
        return topLevelObjects;
    }, 

   _calculateRollups: function(object_tree){
        var me = this;
        me.logger.log('_calculateRollups', object_tree['children'], object_tree['ObjectID']);
        
        var children = object_tree['children'];
        if (!(children && children.length > 0)) {
            return; 
        }

        var cumulative_completed = 0; //cumulative total for each  iteration 
        var cumulative_estimated = 0;
        var total_estimated = 0;
        for(var i=0; i<me.iterations.length; i++){
            var iteration_estimated = 0;
            var iteration_completed=0;
            Ext.Array.each(children, function(child){
//                if (child.leaf == false ){
                    iteration_estimated = iteration_estimated + child[me._getRollupEstimatedField(i)];
                    iteration_completed = iteration_completed + child[me._getRollupCompletedField(i)];

                    object_tree[me._getRollupEstimatedField(i)] = iteration_estimated;
                    object_tree[me._getRollupCompletedField(i)] = iteration_completed;
//                } else {  // for leaf children when doing cumulative roll ups
//                    cumulative_estimated = cumulative_estimated + child[me._getRollupEstimatedField(i)];
//                    cumulative_completed = cumulative_completed + child[me._getRollupCompletedField(i)];
//                    
//                    object_tree[me._getRollupEstimatedField(i)] = cumulative_estimated;
//                    object_tree[me._getRollupCompletedField(i)] = cumulative_completed;
//                }
            });
            if (i==me.iterations.length-1) total_estimated = total_estimated + object_tree[me._getRollupEstimatedField(i)];
            console.log('children',object_tree['FormattedID'],me._getIterationKey(i),object_tree[me._getRollupEstimatedField(i)],object_tree[me._getRollupCompletedField(i)]);

        }

        //This makes the denominator the total
        for (var i=0; i< me.iterations.length; i++){
            object_tree[me._getRollupEstimatedField(i)]=total_estimated;
        }
        
    },
    _defineFieldModel: function(){
        this.logger.log('_defineFieldModel');
       // extend the model to add fields
        var me = this; 
        var fields = [];
        
        fields.push({ name:'FormattedID', type: 'String' });
        fields.push({name:'Name', type:'String' });

        for (var i=0; i<me.iterations.length; i++) {
            fields.push({name: me._getIterationKey(i), type:'String'});
            fields.push({name: me._getRollupEstimatedField(i), type:'Float'});
            fields.push({name: me._getRollupCompletedField(i), type:'Float'});
        }
            
        var model = {
            extend: 'Ext.data.Model',
            fields: fields
        };
        me.logger.log("Made a model using these fields: ", fields);
        return model;
    },
    _getLowestLevelObjectIds: function(data){
        var object_ids = [];
        Ext.Array.each(data,function(item){
            object_ids.push(item.data['ObjectID']);
        });
        return object_ids;
    },
    _loadTreeData: function(lowest_level_pi_objects, asOfDate){
        //Basically load all the PI data in the item hierarchy for hte lower level objects
        var me = this; 
        var object_ids = [];
        Ext.Array.each(lowest_level_pi_objects,function(llpi){
            var item_hierarchy = llpi.data['_ItemHierarchy'];
            Ext.Array.each(item_hierarchy,function(ih){
                object_ids.push(ih);
            });
        });
        me.logger.log('_loadTreeData',lowest_level_pi_objects.length, object_ids);
        var deferred = Ext.create('Deft.Deferred');
        Ext.create('Rally.data.lookback.SnapshotStore', {
            scope: this,
            listeners: {
                scope: this,
                load: function(store, data, success){
                    if (success){
                        me.logger.log('_loadTreeData success', data);
                        deferred.resolve(data);
                    } else {
                        me.logger.log('_loadTreeData.failure');
                        deferred.reject('Error loading details for top level object ids');
                    }
                }
            },
            autoLoad: true,
            fetch: ['Name','FormattedID','ObjectID','_ItemHierarchy','Iteration','Release','DirectChildrenCount','Children','UserStories','_TypeHierarchy'],
            filters: [{
                      property: 'ObjectID',
                      operator: 'in',
                      value: object_ids
            },
            {
                property: '__At',
                value: "current"
            }]
        });      
        return deferred; 

    },
    _buildTreeStore: function(data, releases){
        this.logger.log('_buildTreeStore', data);
        var me = this;  
        var topLevelObjects = this._getTopLevelObjectIds(data);
        var tree_nodes = {};
        var epics = this._getLowestLevelObjectIds(data);

        var promises = [];
        promises.push(this._loadDetailData(topLevelObjects,"current"));
        promises.push(this._loadStoryDetailData(epics,"current"));

        Deft.Promise.all(promises).then({
            scope:this,
            success: function(returned_data){
                this.logger.log('Loading Data success.', returned_data);

                //Now load the iterations that we want to have as column headers.  
                this._loadIterations(returned_data[1]).then({
                    scope:this, 
                    success: function(){
                        this.logger.log('Loaded Iterations:', me.iterations);
                        tree_nodes = me._buildTreeNodeDataStructure(returned_data[0],returned_data[1],topLevelObjects,epics);
                        var model = me._defineFieldModel();
                        Ext.define('TSTreeModelWithIterations', model);        
                        
                        var treeStore = Ext.create('Ext.data.TreeStore',{
                            model: TSTreeModelWithIterations,
                            root: {
                                expanded: false,
                                children: tree_nodes
                                }
                        });
                        me._buildTree(treeStore); 
                    },
                    failure: function(){
                        this.logger.log('Loading Iterations failed.');
                    }
                });
            },
            failure: function(){
                this.logger.log('Loading Data failed.');
            }
        });
    },
    
    _buildTree: function(tree_store){
        this.logger.log('_buildTree');
        var me = this;
        
        if (me.down('#pi-progress-tree')){
            me.down('#pi-progress-tree').destroy();
        }

        var tree_columns = me._getTreeColumns();
        me.down('#display_box').add({
            scope:this,
            xtype:'treepanel',
            itemId: 'pi-progress-tree',
            store: tree_store,
            rootVisible: false,
            autoLoad: true,
            columns: tree_columns
        });
        
    },
   _getTreeColumns: function(){
        this.logger.log('_getTreeColumns');
        var me = this;
        me.logger.log("_getColumns");
        
        var columns = [
            {
                xtype: 'treecolumn',
                text: 'FormattedID',
                dataIndex: 'FormattedID',
                itemId: 'tree_column',
                renderer: function(value,meta_data,record) {
                    return value + ": " + record.get('Name');
                },
                width: 200
            }];
        for (var i=0; i< me.iterations.length; i++){
            var column_header = me._getIterationName(i);
            var column_index = me._getIterationKey(i);

            var iteration_column = {
                    dataIndex: column_index,
                    text: column_header,
                    itemId:column_index + '_column',
                    width: 100,
                    renderer: function(value,meta_data,record) {
                        return Ext.create('Rally.technicalservices.ProgressBarTemplate',{
                                numeratorField: '_RollupCompleted_' + value,
                                denominatorField: '_RollupEstimated_' + value,
                                percentDoneName: ''
                            }).apply(record.getData());
                           
//                            if (record.get('_RollupEstimated_' + value) > 0 ){
//                            return Math.round(record.get('_RollupCompleted_' + value)/record.get('_RollupEstimated_' + value) * 100) + '%';
//                        } else {
//                            return ('N/A');
//                        }
                    },
                    menuDisabled: true
                };
                columns.push(iteration_column);
        }
        me.logger.log("Making Columns ", columns);
        return columns;        
    },
    
    _loadIterations: function(story_data){
        this.logger.log('_loadIterations');
        var me = this;
        var deferred = Ext.create('Deft.Deferred');

        var release_start_date = this._getReleaseStartDate();
        var release_end_date = this._getReleaseEndDate();
        
        var filter = Ext.create('Rally.data.wsapi.Filter', { property:'StartDate',operator: '<', value: release_end_date });
        filter = filter.and(Ext.create('Rally.data.wsapi.Filter', { property:'EndDate',operator: '>', value: release_start_date }));

        var epic_iterations = [];
        Ext.Array.each(story_data, function(sd){
            if(!Ext.Array.contains(epic_iterations,sd.getData().Iteration)){
                epic_iterations.push(sd.getData().Iteration);
            }
        });
        
        
        Ext.create('Rally.data.wsapi.Store',{
            model: 'Iteration',
            autoLoad: true,
            listeners: {
                scope:this,
                load: function(store, data, success){
                    if (success){
                        this.logger.log('Success loading Iterations', data);
                        
                        
                        me.iterations = [];
                        Ext.Array.each(data,function(rec){
                            var rec_data = rec.getData();
                            if (Ext.Array.contains(epic_iterations,rec_data.ObjectID)){
                                me.iterations.push([rec_data.ObjectID,rec_data.Name,rec_data.EndDate,rec_data.Project.Name]);
                            }
                       });
                        this.logger.log(me.iterations);
                        deferred.resolve();                        
                    } else {
                        this.logger.log('Failed loading Iterations', success);
                        deferred.reject();
                    }
                }
            },
            filters: filter,
            fetch: ['ObjectID','Name','StartDate','EndDate','Project','Workspace'] ,
            context: {project: null},
            sorters: [{
                property: 'StartDate',
                direction: 'ASC'
            }]
            
        });
        return deferred.promise; 
    },
    x_loadIterations: function(releaseStartDate, releaseEndDate){
        this.logger.log('_loadIterations');
        var deferred = Ext.create('Deft.Deferred');

        Ext.create('Rally.data.wsapi.Store',{
            model: 'Iteration',
            autoLoad: true,
            listeners: {
                scope:this,
                load: function(store, data, success){
                    if (success){
                        this.logger.log('Success loading Iterations', data);
                        deferred.resolve(data);                        
                    } else {
                        this.logger.log('Failed loading Iterations');
                        deferred.reject();
                    }
                }
            },
            fetch: ['ObjectID','Name','StartDate','EndDate','Project','Workspace'] ,
            context: {project: null},
            filters: [{
                property: 'EndDate',
                operator: '>',
                value: releaseStartDate.toISOString()
            },{
                property: 'StartDate',
                operator: '<',
                value: releaseEndDate.toISOString()
            }],
            sorters: [{
                property: 'StartDate',
                direction: 'ASC'
            }]
            
        });
        return deferred.promise; 
    }
        
   

});

            
               Rally.launchApp('CustomApp', {
                   name: 'pi-progress-tree'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}
.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}

.x-tree-icon { display: none !important; }

.x-column-header {
    border-bottom-color: rgb(34, 34, 34);
    border-bottom-style: solid;
    border-bottom-width: 4px;
    border-top-style: none;
}
.x-panel-default, .x-grid-header-ct, .yes-harmonized .x-panel-body-default  {
    border-color: #fff;
}

.x-grid-cell-inner {
    font-family: NotoSans, Helvetica, Arial;
    font-size: 12px;
}

    
.yes-harmonized .rally-grid.x-grid .x-grid-header-ct .x-box-inner {
    border-bottom: none;
}
   body {
            overflow-y: auto !important;
        }
        
        .app {
            margin: 10px 30px;
        }
        
        .app > .leftSide {
            float: left;
            width: 45%;
        }
        
        .app > .rightSide {
            float: right;
            width: 45%;
        }
        
        h1 {
            font-size: 14px;
            margin: 5px;
        }
        
        .grayLabel {
            color: #888;
            margin: 5px 15px;
        }
        
        
        .percentDoneContainer {
            height: 15px;
            line-height: 15px;
        }
        
        .planEstimate {
            width: 20px;
            height: 20px;
            border: 1px dotted #5C9ACB;
            text-align: center;
            margin-right: 4px;
            position: absolute;
            top: 5px;
            right: 3px;
        }   
    </style>

</head>
<body></body>
</html>